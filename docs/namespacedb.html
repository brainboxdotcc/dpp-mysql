<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DPP-MySQL: db Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DPP-MySQL
   </div>
   <div id="projectbrief">An extremely lightweight MySQL wrapper for D++ bots</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedb.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">db Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Database abstraction layer Abstracts mysql C connector, supporting prepared statements and caching.  
<a href="namespacedb.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1resultset.html">resultset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a result set. Supports iteration and accessing its rows via operator[] and <a class="el" href="structdb_1_1resultset.html#a50bb1893834affc727cfef157b45c629">at()</a>. You can also insert new rows with emplace_back and <a class="el" href="structdb_1_1resultset.html#a028a9421200bdbf595e7d403f216988a">push_back()</a>.  <a href="structdb_1_1resultset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9a28ec123a44c5f84d5957eb9f5ce96c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a9a28ec123a44c5f84d5957eb9f5ce96c">row</a> = std::map&lt; std::string, std::string &gt;</td></tr>
<tr class="memdesc:a9a28ec123a44c5f84d5957eb9f5ce96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a row in a result set.  <a href="namespacedb.html#a9a28ec123a44c5f84d5957eb9f5ce96c">More...</a><br /></td></tr>
<tr class="separator:a9a28ec123a44c5f84d5957eb9f5ce96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e8c4c6ec113d7a0c0fc8e09cb2736e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a04e8c4c6ec113d7a0c0fc8e09cb2736e">sql_query_callback</a> = std::function&lt; void(const <a class="el" href="structdb_1_1resultset.html">resultset</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a04e8c4c6ec113d7a0c0fc8e09cb2736e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback which happens when an asynchronous SQL query is completed.  <a href="namespacedb.html#a04e8c4c6ec113d7a0c0fc8e09cb2736e">More...</a><br /></td></tr>
<tr class="separator:a04e8c4c6ec113d7a0c0fc8e09cb2736e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab43b4eb6eb0a777ab4eaebec076f5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a5ab43b4eb6eb0a777ab4eaebec076f5f">parameter_type</a> = std::variant&lt; float, std::string, uint64_t, int64_t, bool, int32_t, uint32_t, double &gt;</td></tr>
<tr class="memdesc:a5ab43b4eb6eb0a777ab4eaebec076f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible parameter types for SQL parameters.  <a href="namespacedb.html#a5ab43b4eb6eb0a777ab4eaebec076f5f">More...</a><br /></td></tr>
<tr class="separator:a5ab43b4eb6eb0a777ab4eaebec076f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7195db6c7dd62386e36f3d9ea0c24f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> = std::vector&lt; <a class="el" href="namespacedb.html#a5ab43b4eb6eb0a777ab4eaebec076f5f">parameter_type</a> &gt;</td></tr>
<tr class="memdesc:af7195db6c7dd62386e36f3d9ea0c24f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of database query parameters. These will be translated into prepared statement arguments.  <a href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">More...</a><br /></td></tr>
<tr class="separator:af7195db6c7dd62386e36f3d9ea0c24f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a004a2115b829e9f7258f4f65fcbe0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a8a004a2115b829e9f7258f4f65fcbe0b">init</a> (dpp::cluster &amp;bot)</td></tr>
<tr class="memdesc:a8a004a2115b829e9f7258f4f65fcbe0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise database connection.  <a href="namespacedb.html#a8a004a2115b829e9f7258f4f65fcbe0b">More...</a><br /></td></tr>
<tr class="separator:a8a004a2115b829e9f7258f4f65fcbe0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f6e9e0eb590eaf8ae67fba44cf6689"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#aa2f6e9e0eb590eaf8ae67fba44cf6689">connect</a> (const std::string &amp;host, const std::string &amp;user, const std::string &amp;pass, const std::string &amp;db, int port=3306, const std::string &amp;socket=&quot;&quot;)</td></tr>
<tr class="memdesc:aa2f6e9e0eb590eaf8ae67fba44cf6689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to database and set options.  <a href="namespacedb.html#aa2f6e9e0eb590eaf8ae67fba44cf6689">More...</a><br /></td></tr>
<tr class="separator:aa2f6e9e0eb590eaf8ae67fba44cf6689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0c7c86dc46a5ce6d6200248df5f9f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a4d0c7c86dc46a5ce6d6200248df5f9f0">close</a> ()</td></tr>
<tr class="memdesc:a4d0c7c86dc46a5ce6d6200248df5f9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect from database and free query cache.  <a href="namespacedb.html#a4d0c7c86dc46a5ce6d6200248df5f9f0">More...</a><br /></td></tr>
<tr class="separator:a4d0c7c86dc46a5ce6d6200248df5f9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e64d322c430542846327f26e9d00ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdb_1_1resultset.html">resultset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6">query</a> (const std::string &amp;format, const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;parameters={})</td></tr>
<tr class="memdesc:a8e64d322c430542846327f26e9d00ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a mysql query, with automatic escaping of parameters to prevent SQL injection.  <a href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6">More...</a><br /></td></tr>
<tr class="separator:a8e64d322c430542846327f26e9d00ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0f9df97c2f20440869770847ecde04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#aeb0f9df97c2f20440869770847ecde04">query_callback</a> (const std::string &amp;format, const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;parameters, const <a class="el" href="namespacedb.html#a04e8c4c6ec113d7a0c0fc8e09cb2736e">sql_query_callback</a> &amp;cb)</td></tr>
<tr class="memdesc:aeb0f9df97c2f20440869770847ecde04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a mysql query asynchronously, with automatic escaping of parameters to prevent SQL injection. Call the callback on completion.  <a href="namespacedb.html#aeb0f9df97c2f20440869770847ecde04">More...</a><br /></td></tr>
<tr class="separator:aeb0f9df97c2f20440869770847ecde04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af873c3dbbe3724ee0e31953ade03f2bd"><td class="memItemLeft" align="right" valign="top">dpp::async&lt; <a class="el" href="structdb_1_1resultset.html">resultset</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd">co_query</a> (const std::string &amp;format, const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;parameters={})</td></tr>
<tr class="memdesc:af873c3dbbe3724ee0e31953ade03f2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a mysql query, with automatic escaping of parameters to prevent SQL injection. This is the coroutine asynchronous version of <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query</a>. It will complete its dpp::async once the query has finished without blocking, by means of a separate thread.  <a href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd">More...</a><br /></td></tr>
<tr class="separator:af873c3dbbe3724ee0e31953ade03f2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cf41cd981806e9f418472a6d5e640b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdb_1_1resultset.html">resultset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a80cf41cd981806e9f418472a6d5e640b">query</a> (const std::string &amp;format, const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;parameters, double lifetime)</td></tr>
<tr class="memdesc:a80cf41cd981806e9f418472a6d5e640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a mysql query, with automatic escaping of parameters to prevent SQL injection.  <a href="namespacedb.html#a80cf41cd981806e9f418472a6d5e640b">More...</a><br /></td></tr>
<tr class="separator:a80cf41cd981806e9f418472a6d5e640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e993a57250f29c283e2215218c08ad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a20e993a57250f29c283e2215218c08ad">affected_rows</a> ()</td></tr>
<tr class="memdesc:a20e993a57250f29c283e2215218c08ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of affected rows from an UPDATE, INSERT, DELETE.  <a href="namespacedb.html#a20e993a57250f29c283e2215218c08ad">More...</a><br /></td></tr>
<tr class="separator:a20e993a57250f29c283e2215218c08ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b1577c4b3310854fcfbbbd92e70c0b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#ad9b1577c4b3310854fcfbbbd92e70c0b">error</a> ()</td></tr>
<tr class="memdesc:ad9b1577c4b3310854fcfbbbd92e70c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last error string.  <a href="namespacedb.html#ad9b1577c4b3310854fcfbbbd92e70c0b">More...</a><br /></td></tr>
<tr class="separator:ad9b1577c4b3310854fcfbbbd92e70c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda338dba46c43746e4a2e335e23123c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#adda338dba46c43746e4a2e335e23123c">cache_size</a> ()</td></tr>
<tr class="memdesc:adda338dba46c43746e4a2e335e23123c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the query cache.  <a href="namespacedb.html#adda338dba46c43746e4a2e335e23123c">More...</a><br /></td></tr>
<tr class="separator:adda338dba46c43746e4a2e335e23123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211fc5ec27542766439426c02a051cc0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a211fc5ec27542766439426c02a051cc0">query_count</a> ()</td></tr>
<tr class="memdesc:a211fc5ec27542766439426c02a051cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total number of queries executed since connection was established.  <a href="namespacedb.html#a211fc5ec27542766439426c02a051cc0">More...</a><br /></td></tr>
<tr class="separator:a211fc5ec27542766439426c02a051cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4f92b15fde6491a19818b96b0d79d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a2b4f92b15fde6491a19818b96b0d79d9">transaction</a> (std::function&lt; bool()&gt; closure, <a class="el" href="namespacedb.html#a04e8c4c6ec113d7a0c0fc8e09cb2736e">sql_query_callback</a> callback={})</td></tr>
<tr class="memdesc:a2b4f92b15fde6491a19818b96b0d79d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an SQL transaction. SQL transactions are atomic in nature, ALL other queries will be forced to wait. The transaction will be inserted into the queue to run as one atomic operation, meaning that <a class="el" href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection....">db::co_query</a> cannot disrupt it or insert queries in the middle of it, and <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query</a> function calls that are not within the closure will be forced to wait.  <a href="namespacedb.html#a2b4f92b15fde6491a19818b96b0d79d9">More...</a><br /></td></tr>
<tr class="separator:a2b4f92b15fde6491a19818b96b0d79d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cba5870abb1d49fe0f9fe17dd8ef15f"><td class="memItemLeft" align="right" valign="top">dpp::async&lt; <a class="el" href="structdb_1_1resultset.html">resultset</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html#a7cba5870abb1d49fe0f9fe17dd8ef15f">co_transaction</a> (std::function&lt; bool()&gt; closure)</td></tr>
<tr class="memdesc:a7cba5870abb1d49fe0f9fe17dd8ef15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an SQL transaction in a coroutine that can be awaited. SQL transactions are atomic in nature, ALL other queries will be forced to wait. The transaction will be inserted into the queue to run as one atomic operation, meaning that <a class="el" href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection....">db::co_query</a> cannot disrupt it or insert queries in the middle of it, and <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query</a> function calls that are not within the closure will be forced to wait.  <a href="namespacedb.html#a7cba5870abb1d49fe0f9fe17dd8ef15f">More...</a><br /></td></tr>
<tr class="separator:a7cba5870abb1d49fe0f9fe17dd8ef15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Database abstraction layer Abstracts mysql C connector, supporting prepared statements and caching. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a5ab43b4eb6eb0a777ab4eaebec076f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab43b4eb6eb0a777ab4eaebec076f5f">&#9670;&nbsp;</a></span>parameter_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedb.html#a5ab43b4eb6eb0a777ab4eaebec076f5f">db::parameter_type</a> = typedef std::variant&lt;float, std::string, uint64_t, int64_t, bool, int32_t, uint32_t, double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible parameter types for SQL parameters. </p>

</div>
</div>
<a id="af7195db6c7dd62386e36f3d9ea0c24f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7195db6c7dd62386e36f3d9ea0c24f8">&#9670;&nbsp;</a></span>paramlist</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">db::paramlist</a> = typedef std::vector&lt;<a class="el" href="namespacedb.html#a5ab43b4eb6eb0a777ab4eaebec076f5f">parameter_type</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of database query parameters. These will be translated into prepared statement arguments. </p>

</div>
</div>
<a id="a9a28ec123a44c5f84d5957eb9f5ce96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a28ec123a44c5f84d5957eb9f5ce96c">&#9670;&nbsp;</a></span>row</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedb.html#a9a28ec123a44c5f84d5957eb9f5ce96c">db::row</a> = typedef std::map&lt;std::string, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a row in a result set. </p>

</div>
</div>
<a id="a04e8c4c6ec113d7a0c0fc8e09cb2736e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e8c4c6ec113d7a0c0fc8e09cb2736e">&#9670;&nbsp;</a></span>sql_query_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedb.html#a04e8c4c6ec113d7a0c0fc8e09cb2736e">db::sql_query_callback</a> = typedef std::function&lt;void(const <a class="el" href="structdb_1_1resultset.html">resultset</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback which happens when an asynchronous SQL query is completed. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a20e993a57250f29c283e2215218c08ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e993a57250f29c283e2215218c08ad">&#9670;&nbsp;</a></span>affected_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t db::affected_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of affected rows from an UPDATE, INSERT, DELETE. </p>
<dl class="section note"><dt>Note</dt><dd>This value is by any <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query()</a> call. Take a copy! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>size_t Number of affected rows </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This is not coroutine-safe and you should use <a class="el" href="structdb_1_1resultset.html#a389e90d46194b5d1bc34ea7f878f75cc">resultset::affected_rows</a> instead </dd></dl>

</div>
</div>
<a id="adda338dba46c43746e4a2e335e23123c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda338dba46c43746e4a2e335e23123c">&#9670;&nbsp;</a></span>cache_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t db::cache_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the query cache. </p>
<p>Prepared statement handles are stored in a std::map along with their metadata, so that they don't have to be re-prepared if they are executed repeatedly. This is a diagnostic and informational function which returns the size of that map.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t Cache size </dd></dl>

</div>
</div>
<a id="a4d0c7c86dc46a5ce6d6200248df5f9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0c7c86dc46a5ce6d6200248df5f9f0">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool db::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect from database and free query cache. </p>
<dl class="section return"><dt>Returns</dt><dd>true on successful disconnection </dd></dl>

</div>
</div>
<a id="af873c3dbbe3724ee0e31953ade03f2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af873c3dbbe3724ee0e31953ade03f2bd">&#9670;&nbsp;</a></span>co_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dpp::async&lt;<a class="el" href="structdb_1_1resultset.html">resultset</a>&gt; db::co_query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a mysql query, with automatic escaping of parameters to prevent SQL injection. This is the coroutine asynchronous version of <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query</a>. It will complete its dpp::async once the query has finished without blocking, by means of a separate thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format string, where each parameter should be indicated by a ? symbol </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameters to prepare into the query in place of the ?'s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dpp::async which you can co_await to get the result set.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is the nature of asynchronous APIs like this that they cannot be atomic. Therefore do not combine transactions with asynchronous co_query. If you do, other queries may end up muddled into your transaction. This wrapper ensures the correct order of statements passed to co_query from the same origin thread, however statements from other threads, or statements via <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query()</a> instead are not queued. Pick one interface, or the other!</dd></dl>
<p>The parameters given should be a vector of strings. You can instantiate this using "{}". The queries are cached as prepared statements and therefore do not need quote symbols to be placed around parameters in the query. These will be automatically added if required.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> rs = co_await <a class="code" href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd">db::co_query</a>(<span class="stringliteral">&quot;SELECT * FROM bigtable WHERE bar = ?&quot;</span>, { <span class="stringliteral">&quot;baz&quot;</span> });</div>
<div class="ttc" id="anamespacedb_html_af873c3dbbe3724ee0e31953ade03f2bd"><div class="ttname"><a href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd">db::co_query</a></div><div class="ttdeci">dpp::async&lt; resultset &gt; co_query(const std::string &amp;format, const paramlist &amp;parameters={})</div><div class="ttdoc">Run a mysql query, with automatic escaping of parameters to prevent SQL injection....</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7cba5870abb1d49fe0f9fe17dd8ef15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cba5870abb1d49fe0f9fe17dd8ef15f">&#9670;&nbsp;</a></span>co_transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dpp::async&lt;<a class="el" href="structdb_1_1resultset.html">resultset</a>&gt; db::co_transaction </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool()&gt;&#160;</td>
          <td class="paramname"><em>closure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an SQL transaction in a coroutine that can be awaited. SQL transactions are atomic in nature, ALL other queries will be forced to wait. The transaction will be inserted into the queue to run as one atomic operation, meaning that <a class="el" href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection....">db::co_query</a> cannot disrupt it or insert queries in the middle of it, and <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query</a> function calls that are not within the closure will be forced to wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">closure</td><td>The transactional code to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Awaitable, returns an empty resultset on completion of transaction</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The closure should only ever execute queries using <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query()</a>, it should NOT use async queries/co_query() as these cannot be executed atomically. Returning false from the closure, or throwing any exception at all will roll back the transaction, else it will be committed when the closure ends. </dd></dl>

</div>
</div>
<a id="aa2f6e9e0eb590eaf8ae67fba44cf6689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f6e9e0eb590eaf8ae67fba44cf6689">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool db::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em> = <code>3306</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>socket</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to database and set options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Database hostname </td></tr>
    <tr><td class="paramname">user</td><td>Database username </td></tr>
    <tr><td class="paramname">pass</td><td>Database password </td></tr>
    <tr><td class="paramname">db</td><td>Database schema name </td></tr>
    <tr><td class="paramname">port</td><td>Database port number </td></tr>
    <tr><td class="paramname">socket</td><td>unix socket path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the database connection succeeded</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unix socket and port number are mutually exclusive. If you set socket to a non-empty string, you should set port to 0 and host to <code>localhost</code>. This is a special value in the mysql client and causes a unix socket connection to occur. If you do not want to use unix sockets, keep the value as an empty string. </dd></dl>

</div>
</div>
<a id="ad9b1577c4b3310854fcfbbbd92e70c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b1577c4b3310854fcfbbbd92e70c0b">&#9670;&nbsp;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; db::error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last error string. </p>
<dl class="section note"><dt>Note</dt><dd>This value is by any <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query()</a> call. Take a copy! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>const std::string&amp; Error mesage </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This is not coroutine-safe and you should use <a class="el" href="structdb_1_1resultset.html#ad28608b9530c9de5cb0b9f1b87a7e785">resultset::error</a> instead </dd></dl>

</div>
</div>
<a id="a8a004a2115b829e9f7258f4f65fcbe0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a004a2115b829e9f7258f4f65fcbe0b">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void db::init </td>
          <td>(</td>
          <td class="paramtype">dpp::cluster &amp;&#160;</td>
          <td class="paramname"><em>bot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise database connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bot</td><td>creating D++ cluster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80cf41cd981806e9f418472a6d5e640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cf41cd981806e9f418472a6d5e640b">&#9670;&nbsp;</a></span>query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdb_1_1resultset.html">resultset</a> db::query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lifetime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a mysql query, with automatic escaping of parameters to prevent SQL injection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format string, where each parameter should be indicated by a ? symbol </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameters to prepare into the query in place of the ?'s </td></tr>
    <tr><td class="paramname">lifetime</td><td>How long to cache this query's resultset in memory for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result set</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the query is already cached in memory, the cached resultset will be returned instead of querying the database.</dd></dl>
<p>The parameters given should be a vector of strings. You can instantiate this using "{}". The queries are cached as prepared statements and therefore do not need quote symbols to be placed around parameters in the query. These will be automatically added if required. </p>

</div>
</div>
<a id="a8e64d322c430542846327f26e9d00ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e64d322c430542846327f26e9d00ff6">&#9670;&nbsp;</a></span>query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdb_1_1resultset.html">resultset</a> db::query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a mysql query, with automatic escaping of parameters to prevent SQL injection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format string, where each parameter should be indicated by a ? symbol </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameters to prepare into the query in place of the ?'s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result set</dd></dl>
<p>The parameters given should be a vector of strings. You can instantiate this using "{}". The queries are cached as prepared statements and therefore do not need quote symbols to be placed around parameters in the query. These will be automatically added if required.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6">db::query</a>(<span class="stringliteral">&quot;UPDATE foo SET bar = ? WHERE id = ?&quot;</span>, { <span class="stringliteral">&quot;baz&quot;</span>, 3 });</div>
<div class="ttc" id="anamespacedb_html_a8e64d322c430542846327f26e9d00ff6"><div class="ttname"><a href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6">db::query</a></div><div class="ttdeci">resultset query(const std::string &amp;format, const paramlist &amp;parameters={})</div><div class="ttdoc">Run a mysql query, with automatic escaping of parameters to prevent SQL injection.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aeb0f9df97c2f20440869770847ecde04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0f9df97c2f20440869770847ecde04">&#9670;&nbsp;</a></span>query_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void db::query_callback </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedb.html#af7195db6c7dd62386e36f3d9ea0c24f8">paramlist</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedb.html#a04e8c4c6ec113d7a0c0fc8e09cb2736e">sql_query_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a mysql query asynchronously, with automatic escaping of parameters to prevent SQL injection. Call the callback on completion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format string, where each parameter should be indicated by a ? symbol </td></tr>
    <tr><td class="paramname">parameters</td><td>Parameters to prepare into the query in place of the ?'s </td></tr>
    <tr><td class="paramname">cb</td><td>Callback to call on completion of the query. The callback will be passed the resultset as its parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The parameters given should be a vector of strings. You can instantiate this using "{}". The queries are cached as prepared statements and therefore do not need quote symbols to be placed around parameters in the query. These will be automatically added if required.</p>
<dl class="section note"><dt>Note</dt><dd>If you can you should use co_query instead to avoid callback hell. co_query uses this internally, wrapping it with dpp::async&lt;&gt;. </dd></dl>

</div>
</div>
<a id="a211fc5ec27542766439426c02a051cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211fc5ec27542766439426c02a051cc0">&#9670;&nbsp;</a></span>query_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t db::query_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total number of queries executed since connection was established. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t Query counter </dd></dl>

</div>
</div>
<a id="a2b4f92b15fde6491a19818b96b0d79d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4f92b15fde6491a19818b96b0d79d9">&#9670;&nbsp;</a></span>transaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void db::transaction </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool()&gt;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedb.html#a04e8c4c6ec113d7a0c0fc8e09cb2736e">sql_query_callback</a>&#160;</td>
          <td class="paramname"><em>callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an SQL transaction. SQL transactions are atomic in nature, ALL other queries will be forced to wait. The transaction will be inserted into the queue to run as one atomic operation, meaning that <a class="el" href="namespacedb.html#af873c3dbbe3724ee0e31953ade03f2bd" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection....">db::co_query</a> cannot disrupt it or insert queries in the middle of it, and <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query</a> function calls that are not within the closure will be forced to wait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">closure</td><td>The transactional code to execute. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback to call when the transaction completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The closure should only ever execute queries using <a class="el" href="namespacedb.html#a8e64d322c430542846327f26e9d00ff6" title="Run a mysql query, with automatic escaping of parameters to prevent SQL injection.">db::query()</a>, it should NOT use async queries/co_query() as these cannot be executed atomically. Returning false from the closure, or throwing any exception at all will roll back the transaction, else it will be committed when the closure ends. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The coroutine will execute asynchronously in a different thread. You should use the callback to be notified when it completes. The resultset passed as the parameter will be empty. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedb.html">db</a></li>
    <li class="footer">Generated on Mon Jul 15 2024 12:46:34 for DPP-MySQL by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
